// ShadowSniper - PvP Betting Game on Midnight Network
// A round-based betting game with weighted RNG and progressive jackpot
//
// Design: All game data is fully public (disclosed).
// Computation happens off-chain, verification on-chain (ZK pattern).

pragma language_version >= 0.20;

import CompactStandardLibrary;

// Round states
enum RoundState { resolved, open }

// Witnesses for off-chain data
witness callerAddress(): Bytes<32>;
witness currentTime(): Uint<64>;

// --- Ledger State (all public for transparency) ---

export ledger operator: Bytes<32>;
export ledger minBet: Uint<64>;
export ledger maxBet: Uint<64>;
export ledger roundDuration: Uint<64>;
export ledger houseFeePercent: Uint<64>;
export ledger progressivePercent: Uint<64>;
export ledger resolveDeadlineMs: Uint<64>;

export ledger state: RoundState;
export ledger roundNumber: Counter;
export ledger totalRounds: Counter;
export ledger commitment: Field;
export ledger startTime: Uint<64>;
export ledger endTime: Uint<64>;
export ledger resolveDeadline: Uint<64>;
export ledger totalPot: Uint<64>;
export ledger playerCount: Uint<64>;
export ledger progressivePool: Uint<64>;
export ledger houseBalance: Uint<64>;

// 10 fixed bet slots
export ledger bet0_active: Boolean;
export ledger bet0_player: Bytes<32>;
export ledger bet0_amount: Uint<64>;
export ledger bet1_active: Boolean;
export ledger bet1_player: Bytes<32>;
export ledger bet1_amount: Uint<64>;
export ledger bet2_active: Boolean;
export ledger bet2_player: Bytes<32>;
export ledger bet2_amount: Uint<64>;
export ledger bet3_active: Boolean;
export ledger bet3_player: Bytes<32>;
export ledger bet3_amount: Uint<64>;
export ledger bet4_active: Boolean;
export ledger bet4_player: Bytes<32>;
export ledger bet4_amount: Uint<64>;
export ledger bet5_active: Boolean;
export ledger bet5_player: Bytes<32>;
export ledger bet5_amount: Uint<64>;
export ledger bet6_active: Boolean;
export ledger bet6_player: Bytes<32>;
export ledger bet6_amount: Uint<64>;
export ledger bet7_active: Boolean;
export ledger bet7_player: Bytes<32>;
export ledger bet7_amount: Uint<64>;
export ledger bet8_active: Boolean;
export ledger bet8_player: Bytes<32>;
export ledger bet8_amount: Uint<64>;
export ledger bet9_active: Boolean;
export ledger bet9_player: Bytes<32>;
export ledger bet9_amount: Uint<64>;

// Last result
export ledger lastWinner: Bytes<32>;
export ledger lastPayout: Uint<64>;
export ledger lastHouseFee: Uint<64>;

// --- Constructor ---

constructor(
  op: Bytes<32>,
  cfgMinBet: Uint<64>,
  cfgMaxBet: Uint<64>,
  cfgDuration: Uint<64>,
  cfgHouseFee: Uint<64>,
  cfgProgressive: Uint<64>,
  cfgDeadline: Uint<64>
) {
  operator = disclose(op);
  minBet = disclose(cfgMinBet);
  maxBet = disclose(cfgMaxBet);
  roundDuration = disclose(cfgDuration);
  houseFeePercent = disclose(cfgHouseFee);
  progressivePercent = disclose(cfgProgressive);
  resolveDeadlineMs = disclose(cfgDeadline);

  state = RoundState.resolved;
  commitment = 0 as Field;
  startTime = 0;
  endTime = 0;
  resolveDeadline = 0;
  totalPot = 0;
  playerCount = 0;
  progressivePool = 0;
  houseBalance = 0;
  lastWinner = default<Bytes<32>>;
  lastPayout = 0;
  lastHouseFee = 0;

  bet0_active = false; bet0_player = default<Bytes<32>>; bet0_amount = 0;
  bet1_active = false; bet1_player = default<Bytes<32>>; bet1_amount = 0;
  bet2_active = false; bet2_player = default<Bytes<32>>; bet2_amount = 0;
  bet3_active = false; bet3_player = default<Bytes<32>>; bet3_amount = 0;
  bet4_active = false; bet4_player = default<Bytes<32>>; bet4_amount = 0;
  bet5_active = false; bet5_player = default<Bytes<32>>; bet5_amount = 0;
  bet6_active = false; bet6_player = default<Bytes<32>>; bet6_amount = 0;
  bet7_active = false; bet7_player = default<Bytes<32>>; bet7_amount = 0;
  bet8_active = false; bet8_player = default<Bytes<32>>; bet8_amount = 0;
  bet9_active = false; bet9_player = default<Bytes<32>>; bet9_amount = 0;
}

// --- Circuit: Start Round ---

export circuit startRound(newCommitment: Field): [] {
  const caller = callerAddress();
  assert(caller == operator, "Only operator can start rounds");
  assert(state == RoundState.resolved, "Previous round not resolved");

  const time = disclose(currentTime());

  state = RoundState.open;
  roundNumber += 1;
  commitment = disclose(newCommitment);
  startTime = time;
  endTime = (time + roundDuration) as Uint<64>;
  resolveDeadline = (time + roundDuration + resolveDeadlineMs) as Uint<64>;
  totalPot = 0;
  playerCount = 0;

  bet0_active = false; bet0_amount = 0;
  bet1_active = false; bet1_amount = 0;
  bet2_active = false; bet2_amount = 0;
  bet3_active = false; bet3_amount = 0;
  bet4_active = false; bet4_amount = 0;
  bet5_active = false; bet5_amount = 0;
  bet6_active = false; bet6_amount = 0;
  bet7_active = false; bet7_amount = 0;
  bet8_active = false; bet8_amount = 0;
  bet9_active = false; bet9_amount = 0;
}

// --- Circuit: Place Bet ---

export circuit placeBet(amount: Uint<64>): [] {
  const player = disclose(callerAddress());
  const time = currentTime();

  assert(state == RoundState.open, "Round not open for bets");
  assert(disclose(time) < endTime, "Round has ended");
  assert(disclose(amount) >= minBet, "Bet below minimum");
  assert(disclose(amount) <= maxBet, "Bet above maximum");
  assert(playerCount < 10, "Round is full");

  // Check player hasn't already bet
  assert(!(bet0_active && bet0_player == player), "Already placed bet");
  assert(!(bet1_active && bet1_player == player), "Already placed bet");
  assert(!(bet2_active && bet2_player == player), "Already placed bet");
  assert(!(bet3_active && bet3_player == player), "Already placed bet");
  assert(!(bet4_active && bet4_player == player), "Already placed bet");
  assert(!(bet5_active && bet5_player == player), "Already placed bet");
  assert(!(bet6_active && bet6_player == player), "Already placed bet");
  assert(!(bet7_active && bet7_player == player), "Already placed bet");
  assert(!(bet8_active && bet8_player == player), "Already placed bet");
  assert(!(bet9_active && bet9_player == player), "Already placed bet");

  // Place bet in next slot
  if (playerCount == 0) { bet0_active = true; bet0_player = player; bet0_amount = disclose(amount); }
  if (playerCount == 1) { bet1_active = true; bet1_player = player; bet1_amount = disclose(amount); }
  if (playerCount == 2) { bet2_active = true; bet2_player = player; bet2_amount = disclose(amount); }
  if (playerCount == 3) { bet3_active = true; bet3_player = player; bet3_amount = disclose(amount); }
  if (playerCount == 4) { bet4_active = true; bet4_player = player; bet4_amount = disclose(amount); }
  if (playerCount == 5) { bet5_active = true; bet5_player = player; bet5_amount = disclose(amount); }
  if (playerCount == 6) { bet6_active = true; bet6_player = player; bet6_amount = disclose(amount); }
  if (playerCount == 7) { bet7_active = true; bet7_player = player; bet7_amount = disclose(amount); }
  if (playerCount == 8) { bet8_active = true; bet8_player = player; bet8_amount = disclose(amount); }
  if (playerCount == 9) { bet9_active = true; bet9_player = player; bet9_amount = disclose(amount); }

  totalPot = (totalPot + disclose(amount)) as Uint<64>;
  playerCount = (playerCount + 1) as Uint<64>;
}

// --- Circuit: Resolve Round ---
// Operator reveals secret and provides computed payout breakdown.
// Contract verifies: commitment, fee math, winner index validity.

export circuit resolveRound(
  secret: Bytes<32>,
  winnerAddr: Bytes<32>,
  payout: Uint<64>,
  houseFee: Uint<64>,
  progContrib: Uint<64>
): [] {
  const caller = callerAddress();
  const time = currentTime();

  assert(caller == operator, "Only operator can resolve");
  assert(state == RoundState.open, "No active round");
  assert(disclose(time) >= endTime, "Round not ended yet");
  assert(disclose(time) <= resolveDeadline, "Deadline passed, use cancelRound");

  // Verify commitment
  const secretHash = transientHash<Bytes<32>>(secret);
  assert(secretHash == commitment, "Invalid secret");

  // Handle 0 players
  if (playerCount == 0) {
    assert(disclose(payout) == 0, "No payout for empty round");
    state = RoundState.resolved;
    totalRounds += 1;
    lastWinner = default<Bytes<32>>;
    lastPayout = 0;
    lastHouseFee = 0;
  }

  // Handle 1 player - full refund
  if (playerCount == 1) {
    assert(disclose(payout) == totalPot, "Single player gets full refund");
    assert(disclose(houseFee) == 0, "No fees for single player");
    state = RoundState.resolved;
    totalRounds += 1;
    lastWinner = bet0_player;
    lastPayout = totalPot;
    lastHouseFee = 0;
  }

  // Handle 2+ players
  if (playerCount >= 2) {
    // Verify fee breakdown: payout + houseFee + progContrib == totalPot
    assert(disclose(payout) + disclose(houseFee) + disclose(progContrib) == totalPot, "Payout breakdown invalid");
    assert(disclose(houseFee) * 100 == totalPot * houseFeePercent, "House fee incorrect");
    assert(disclose(progContrib) * 100 == totalPot * progressivePercent, "Progressive fee incorrect");

    // Verify winner is an active bettor
    const w = disclose(winnerAddr);
    assert(
      (bet0_active && bet0_player == w) ||
      (bet1_active && bet1_player == w) ||
      (bet2_active && bet2_player == w) ||
      (bet3_active && bet3_player == w) ||
      (bet4_active && bet4_player == w) ||
      (bet5_active && bet5_player == w) ||
      (bet6_active && bet6_player == w) ||
      (bet7_active && bet7_player == w) ||
      (bet8_active && bet8_player == w) ||
      (bet9_active && bet9_player == w),
      "Winner must be an active bettor"
    );

    houseBalance = (houseBalance + disclose(houseFee)) as Uint<64>;
    progressivePool = (progressivePool + disclose(progContrib)) as Uint<64>;

    state = RoundState.resolved;
    totalRounds += 1;
    lastWinner = w;
    lastPayout = disclose(payout);
    lastHouseFee = disclose(houseFee);
  }
}

// --- Circuit: Cancel Round ---

export circuit cancelRound(): [] {
  const time = currentTime();
  assert(disclose(time) > resolveDeadline, "Resolve deadline not passed yet");
  assert(state == RoundState.open, "No active round to cancel");

  state = RoundState.resolved;
  totalRounds += 1;
  lastWinner = default<Bytes<32>>;
  lastPayout = 0;
  lastHouseFee = 0;
}

// --- Circuit: Update Config ---

export circuit updateConfig(
  newMinBet: Uint<64>,
  newMaxBet: Uint<64>,
  newDuration: Uint<64>,
  newHouseFee: Uint<64>,
  newProgressive: Uint<64>,
  newDeadline: Uint<64>
): [] {
  const caller = callerAddress();
  assert(caller == operator, "Only operator can update config");
  assert(state == RoundState.resolved, "Cannot update during active round");
  assert(disclose(newMinBet) > 0, "Min bet must be positive");
  assert(disclose(newMaxBet) >= disclose(newMinBet), "Max bet must be >= min bet");
  assert(disclose(newHouseFee) + disclose(newProgressive) < 100, "Combined fees must be < 100%");

  minBet = disclose(newMinBet);
  maxBet = disclose(newMaxBet);
  roundDuration = disclose(newDuration);
  houseFeePercent = disclose(newHouseFee);
  progressivePercent = disclose(newProgressive);
  resolveDeadlineMs = disclose(newDeadline);
}

// --- Circuit: Withdraw House Fees ---

export circuit withdrawHouseFees(amount: Uint<64>): [] {
  const caller = callerAddress();
  assert(caller == operator, "Only operator can withdraw fees");
  assert(disclose(amount) <= houseBalance, "Insufficient house balance");
  houseBalance = (houseBalance - disclose(amount)) as Uint<64>;
}
